<!DOCTYPE HTML>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
<!-- <script src="http://img.mukewang.com/down/540812440001e40e00000000.js" type="text/javascript"></script> -->
<script type="text/javascript" src="../jquery-2.1.1.js"></script>
<title></title>
</head>
<body>


<button id="test1">jQuery选择器checked</button>
<button id="test2">querySelector选择器disabled</button>

<div id="text">
  <p>
     <input type="text" />
  </p>
  <div class="aaron">
     <input type="checkbox" name="readme" />
     <input type="checkbox" name="ttt" />
     <input type="checkbox" name="aaa" />
     <p>测试选择器</p>
  </div>
</div>

<script type="text/javascript">

console.log(
    $('div.aaron input[name=ttt]')
  )



var preFilters = {
  ATTR: function(match) {

  },
  CHILD: function(match) {

  },
  PSEUDO: function(match) {

  }
}

var filter = {
  ATTR: function(name, operator, check) {},
  CHILD: function(type, what, argument, first, last) {},
  CLASS: function(className) {},
  ID: function(id) {},
  PSEUDO: function(pseudo, argument) {},
  TAG: function(nodeNameSelector) {}
}

function tokenize(selector) {
  var matched, match, tokens, type,
    soFar, groups, preFilters;

  soFar = selector;
  groups = [];

  while (soFar) {

    // Comma and first run
    if (!matched || (match = rcomma.exec(soFar))) {
      if (match) {
        // Don't consume trailing commas as valid
        soFar = soFar.slice(match[0].length) || soFar;
      }
      groups.push((tokens = []));
    }

    matched = false;

    // Combinators
    if ((match = rcombinators.exec(soFar))) {
      matched = match.shift();
      tokens.push({
        value: matched,
        // Cast descendant combinators to space
        type: match[0].replace(rtrim, " ")
      });
      soFar = soFar.slice(matched.length);
    }

    // Filters
    for (type in Expr.filter) {
      if ((match = matchExpr[type].exec(soFar)) && (!preFilters[type] ||
        (match = preFilters[type](match)))) {
        matched = match.shift();
        tokens.push({
          value: matched,
          type: type,
          matches: match
        });
        soFar = soFar.slice(matched.length);
      }
    }

    if (!matched) {
      break;
    }
  }

  // Return the length of the invalid excess
  // if we're just parsing
  // Otherwise, throw an error or return tokens
  return parseOnly ?
    soFar.length :
    soFar ?
    Sizzle.error(selector) :
  // Cache the tokens
  tokenCache(selector, groups).slice(0);
};



</script> 

</body>
</html>









